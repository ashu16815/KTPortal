import type { WeeklySubmissionDTO } from '@/types'

export interface TowerReportInput {
  name: string
  group: string
  phase: string
  twgScore: number | null
  tcsScore: number | null
  ragStatus: string | null
  overdueActions: number
  openRaidds: number
  narrative: string | null
  risks: string[]
  blockers: string[]
}

export interface ProgrammeReportInput {
  weekEnding: string
  totalTowers: number
  ragCounts: { RED: number; AMBER: number; GREEN: number }
  towers: TowerReportInput[]
  topRaidds: Array<{ type: string; title: string; impact: string; towerName: string }>
  overdueActions: Array<{ title: string; towerName: string; priority: string }>
  atRiskMilestones: Array<{ name: string; towerName: string; status: string }>
  pulseComments: Array<{ track: string; comment: string; towerName: string }>
}

export interface ProgrammeReport {
  summary: string
  workingWell: string
  notWorking: string
  commonRisks: string
  priorityActions: string
  forwardActions: string
}

export interface AIProvider {
  generateSummary(submission: Partial<WeeklySubmissionDTO>, towerName: string): Promise<string>
  generateProgrammeReport(data: ProgrammeReportInput): Promise<ProgrammeReport>
}

class StubAIProvider implements AIProvider {
  async generateSummary(submission: Partial<WeeklySubmissionDTO>, towerName: string): Promise<string> {
    const rag = submission.ragStatus ?? 'AMBER'
    const score = submission.totalScore ?? 0
    return `[AI STUB] KT Status for ${towerName}: Overall health is ${rag} with a score of ${score}/100. ` +
      `Progress is ${submission.progressScore ?? 0}/100, coverage ${submission.coverageScore ?? 0}/100, ` +
      `confidence ${submission.confidenceScore ?? 0}/100. ` +
      `Key narrative: ${submission.narrative ?? 'No narrative provided.'} ` +
      `This summary was generated by the stub AI provider. Set AZURE_OPENAI_KEY to enable real summaries.`
  }

  async generateProgrammeReport(data: ProgrammeReportInput): Promise<ProgrammeReport> {
    const { totalTowers, ragCounts, towers } = data
    const redTowers = towers.filter(t => t.ragStatus === 'RED').map(t => t.name).join(', ')
    return {
      summary: `[AI STUB] Programme Health: ${totalTowers} towers active. RAG: ${ragCounts.GREEN} GREEN, ${ragCounts.AMBER} AMBER, ${ragCounts.RED} RED. Set AZURE_OPENAI_KEY for real AI analysis.`,
      workingWell: '[AI STUB] Multiple towers are progressing through KT phases with consistent scoring from both TWG and TCS teams.',
      notWorking: redTowers ? `[AI STUB] Towers requiring immediate attention: ${redTowers}. Review blockers and escalate as needed.` : '[AI STUB] No critical blockers identified at programme level.',
      commonRisks: '[AI STUB] Cross-tower risks include knowledge concentration, timeline pressure, and resource availability. Review RAIDD log for details.',
      priorityActions: '[AI STUB] 1. Clear all overdue actions. 2. Escalate RED tower issues to steering committee. 3. Ensure weekly submissions are up to date.',
      forwardActions: '[AI STUB] Continue weekly cadence, monitor variance between TWG and TCS scores, and progress milestone completion. Real AI analysis available when AZURE_OPENAI_KEY is configured.',
    }
  }
}

class AzureOpenAIProvider implements AIProvider {
  private apiKey: string
  private endpoint: string
  private deploymentName: string
  private apiVersion: string

  constructor() {
    // Support both AZURE_OPENAI_API_KEY (new) and AZURE_OPENAI_KEY (legacy)
    this.apiKey = (process.env.AZURE_OPENAI_API_KEY ?? process.env.AZURE_OPENAI_KEY)!
    this.endpoint = process.env.AZURE_OPENAI_ENDPOINT!.replace(/\/$/, '')
    this.deploymentName = process.env.AZURE_OPENAI_DEPLOYMENT_GPT5 ?? process.env.AZURE_OPENAI_DEPLOYMENT ?? 'gpt-4o'
    this.apiVersion = process.env.AZURE_OPENAI_API_VERSION ?? '2024-10-01-preview'
  }

  private get url() {
    return `${this.endpoint}/openai/deployments/${this.deploymentName}/chat/completions?api-version=${this.apiVersion}`
  }

  // gpt-5-mini is a reasoning model: uses max_completion_tokens (includes reasoning budget),
  // does not support temperature. Budget must be large enough for internal reasoning + output.
  private buildBody(prompt: string, maxCompletionTokens: number) {
    return JSON.stringify({
      messages: [{ role: 'user', content: prompt }],
      max_completion_tokens: maxCompletionTokens,
    })
  }

  async generateProgrammeReport(data: ProgrammeReportInput): Promise<ProgrammeReport> {
    const { weekEnding, totalTowers, ragCounts, towers, topRaidds, overdueActions, atRiskMilestones, pulseComments } = data

    const towerSummaries = towers.map(t =>
      `- ${t.name} (${t.group}, ${t.phase || 'N/A'}): TWG ${t.twgScore ?? '—'}, TCS ${t.tcsScore ?? '—'}, RAG ${t.ragStatus ?? 'N/A'}` +
      (t.overdueActions > 0 ? `, ${t.overdueActions} overdue action(s)` : '') +
      (t.blockers.length > 0 ? `, BLOCKERS: ${t.blockers.slice(0, 2).join('; ')}` : '') +
      (t.narrative ? `\n  Narrative: ${t.narrative.slice(0, 200)}` : '')
    ).join('\n')

    const raiddSummary = topRaidds.map(r => `- [${r.type} / ${r.impact} impact] ${r.title} — ${r.towerName}`).join('\n') || 'None recorded'
    const actionsSummary = overdueActions.map(a => `- [${a.priority}] ${a.title} — ${a.towerName}`).join('\n') || 'None overdue'
    const milestoneSummary = atRiskMilestones.map(m => `- ${m.name} (${m.towerName}): ${m.status}`).join('\n') || 'None at risk'
    const pulseSummary = pulseComments.map(p => `- ${p.towerName} / ${p.track}: "${p.comment}"`).join('\n') || 'No pulse comments'

    const redTowers   = towers.filter(t => t.ragStatus === 'RED').map(t => t.name)
    const amberTowers = towers.filter(t => t.ragStatus === 'AMBER').map(t => t.name)
    const greenTowers = towers.filter(t => t.ragStatus === 'GREEN').map(t => t.name)
    const totalOverdue = towers.reduce((s, t) => s + t.overdueActions, 0)
    const totalOpenRaidd = overdueActions.length

    const prompt = `ROLE
You are a Managing Partner at a Big Four professional services firm (think McKinsey, Deloitte, PwC, KPMG). You are preparing a board-level executive briefing on a large-scale Knowledge Transfer (KT) transition programme. Your audience is the Steering Committee and Executive Leadership Team — not the delivery team.

WRITING STANDARDS
- Language must be precise, authoritative, and outcome-oriented. Every sentence must earn its place.
- Write in active voice. Attribute actions and risks to named towers or workstreams where evidence supports it.
- Avoid operational detail unless it materially affects an executive decision. Do not list what people are doing — state what it means and what must happen.
- Synthesise patterns across towers rather than describing each one individually.
- Quantify wherever the data permits (scores, counts, percentages, named towers).
- Each section must read as if drafted by a Managing Partner: structured, evidence-based, direct, decision-focused.
- Do not use filler phrases ("it is worth noting", "it should be highlighted", "going forward").
- Bullet points must be complete, standalone statements — not fragments.

PROGRAMME DATA (week ending ${weekEnding})
──────────────────────────────────────────
Portfolio: ${totalTowers} towers  |  GREEN ${ragCounts.GREEN}  |  AMBER ${ragCounts.AMBER}  |  RED ${ragCounts.RED}
RED towers: ${redTowers.join(', ') || 'None'}
AMBER towers: ${amberTowers.join(', ') || 'None'}
GREEN towers: ${greenTowers.join(', ') || 'None'}
Overdue actions (total): ${totalOverdue}

TOWER HEALTH — scores, phase, blockers, narratives
${towerSummaries}

OPEN RAIDD ITEMS (Risks / Assumptions / Issues / Dependencies / Decisions)
${raiddSummary}

OVERDUE ACTIONS
${actionsSummary}

AT-RISK / DELAYED / BLOCKED MILESTONES
${milestoneSummary}

TEAM PULSE COMMENTS
${pulseSummary}
──────────────────────────────────────────

OUTPUT INSTRUCTIONS
Respond ONLY with a single valid JSON object — no markdown fences, no preamble, no commentary outside the JSON.
Use exactly these six keys:

{
  "summary": "3–4 sentences. Open with a clear statement of overall programme health citing the RAG distribution. Name the highest-risk towers and their primary failure mode. Close with the single most important leadership decision required this week. Tone: board paper executive summary.",

  "workingWell": "3–5 bullet points (• prefix, one per line). Each point must name specific towers or workstreams and describe a concrete outcome or positive trajectory — not activity. Focus on what is de-risked, ahead of schedule, or demonstrating strong delivery confidence.",

  "notWorking": "3–5 bullet points (• prefix, one per line). Each point must name the affected tower(s), state the specific failure or gap, and articulate the programme-level implication if unresolved. Do not describe tasks — describe consequences.",

  "commonRisks": "A synthesised 3–4 sentence risk analysis. Identify recurring risk themes cutting across multiple towers (e.g. resource gaps, capability transfer delays, milestone slippage). Quantify where possible. State the aggregate programme impact if these risks materialise. Avoid listing individual RAIDD items — synthesise the pattern.",

  "priorityActions": "5 numbered actions (1. 2. 3. 4. 5.), ordered by urgency and impact. Each action must: (a) state what must happen, (b) name the accountable party or tower, and (c) specify a clear deadline or decision point. Write as board-level directives, not task-list items.",

  "forwardActions": "4–5 bullet points (• prefix, one per line). Strategic outlook for the next 2–4 weeks. Each point must identify a specific risk horizon, required leadership intervention, or programme-level adjustment. Focus on what changes, escalates, or requires decision — not what continues."
}`

    const response = await fetch(this.url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'api-key': this.apiKey },
      body: this.buildBody(prompt, 8000),
    })

    if (!response.ok) {
      const err = await response.json().catch(() => ({}))
      throw new Error(`Azure OpenAI error ${response.status}: ${JSON.stringify(err)}`)
    }

    const result = await response.json()
    const text: string = result.choices?.[0]?.message?.content ?? ''

    // Strip possible markdown code fences the model might still add
    const cleaned = text.replace(/^```(?:json)?\s*/i, '').replace(/\s*```\s*$/, '').trim()
    try {
      return JSON.parse(cleaned) as ProgrammeReport
    } catch {
      // If JSON parse fails, put the raw text in summary so it's still visible
      return {
        summary: cleaned.slice(0, 1000) || 'AI response could not be parsed.',
        workingWell: '', notWorking: '', commonRisks: '', priorityActions: '', forwardActions: '',
      }
    }
  }

  async generateSummary(submission: Partial<WeeklySubmissionDTO>, towerName: string): Promise<string> {
    const prompt = `You are a Managing Partner preparing a one-paragraph executive summary of a single KT tower's weekly submission for the Steering Committee. Be precise, evidence-based, and outcome-oriented. No operational filler.

TOWER DATA
Tower: ${towerName}  |  Org: ${submission.org}  |  Week ending: ${submission.weekEnding}
RAG: ${submission.ragStatus}  |  Total score: ${submission.totalScore}/100
  Progress ${submission.progressScore} | Coverage ${submission.coverageScore} | Confidence ${submission.confidenceScore} | Operational ${submission.operationalScore} | Quality ${submission.qualityScore}
Narrative: ${submission.narrative ?? 'None'}
Risks: ${(submission.risks ?? []).join('; ') || 'None'}
Blockers: ${(submission.blockers ?? []).join('; ') || 'None'}

Write 2–3 sentences. Sentence 1: state the RAG status, overall score, and the primary driver of that rating. Sentence 2: name the most material risk or achievement and its programme implication. Sentence 3 (if warranted): state the single required action and who must take it. Active voice. No fluff.`

    const response = await fetch(this.url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'api-key': this.apiKey },
      body: this.buildBody(prompt, 3000),
    })

    if (!response.ok) throw new Error(`Azure OpenAI error: ${response.status}`)

    const data = await response.json()
    return data.choices?.[0]?.message?.content?.trim() ?? 'Summary unavailable.'
  }
}

export function getAIProvider(): AIProvider {
  const key = process.env.AZURE_OPENAI_API_KEY ?? process.env.AZURE_OPENAI_KEY
  if (key && process.env.AZURE_OPENAI_ENDPOINT) {
    return new AzureOpenAIProvider()
  }
  return new StubAIProvider()
}
