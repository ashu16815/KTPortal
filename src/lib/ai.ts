import type { WeeklySubmissionDTO } from '@/types'

export interface TowerReportInput {
  name: string
  group: string
  phase: string
  twgScore: number | null
  tcsScore: number | null
  ragStatus: string | null
  overdueActions: number
  openRaidds: number
  narrative: string | null
  risks: string[]
  blockers: string[]
}

export interface ProgrammeReportInput {
  weekEnding: string
  totalTowers: number
  ragCounts: { RED: number; AMBER: number; GREEN: number }
  towers: TowerReportInput[]
  topRaidds: Array<{ type: string; title: string; impact: string; towerName: string }>
  overdueActions: Array<{ title: string; towerName: string; priority: string }>
  atRiskMilestones: Array<{ name: string; towerName: string; status: string }>
  pulseComments: Array<{ track: string; comment: string; towerName: string }>
}

export interface ProgrammeReport {
  summary: string
  workingWell: string
  notWorking: string
  commonRisks: string
  priorityActions: string
  forwardActions: string
}

export interface AIProvider {
  generateSummary(submission: Partial<WeeklySubmissionDTO>, towerName: string): Promise<string>
  generateProgrammeReport(data: ProgrammeReportInput): Promise<ProgrammeReport>
}

class StubAIProvider implements AIProvider {
  async generateSummary(submission: Partial<WeeklySubmissionDTO>, towerName: string): Promise<string> {
    const rag = submission.ragStatus ?? 'AMBER'
    const score = submission.totalScore ?? 0
    return `[AI STUB] KT Status for ${towerName}: Overall health is ${rag} with a score of ${score}/100. ` +
      `Progress is ${submission.progressScore ?? 0}/100, coverage ${submission.coverageScore ?? 0}/100, ` +
      `confidence ${submission.confidenceScore ?? 0}/100. ` +
      `Key narrative: ${submission.narrative ?? 'No narrative provided.'} ` +
      `This summary was generated by the stub AI provider. Set AZURE_OPENAI_KEY to enable real summaries.`
  }

  async generateProgrammeReport(data: ProgrammeReportInput): Promise<ProgrammeReport> {
    const { totalTowers, ragCounts, towers } = data
    const redTowers = towers.filter(t => t.ragStatus === 'RED').map(t => t.name).join(', ')
    return {
      summary: `[AI STUB] Programme Health: ${totalTowers} towers active. RAG: ${ragCounts.GREEN} GREEN, ${ragCounts.AMBER} AMBER, ${ragCounts.RED} RED. Set AZURE_OPENAI_KEY for real AI analysis.`,
      workingWell: '[AI STUB] Multiple towers are progressing through KT phases with consistent scoring from both TWG and TCS teams.',
      notWorking: redTowers ? `[AI STUB] Towers requiring immediate attention: ${redTowers}. Review blockers and escalate as needed.` : '[AI STUB] No critical blockers identified at programme level.',
      commonRisks: '[AI STUB] Cross-tower risks include knowledge concentration, timeline pressure, and resource availability. Review RAIDD log for details.',
      priorityActions: '[AI STUB] 1. Clear all overdue actions. 2. Escalate RED tower issues to steering committee. 3. Ensure weekly submissions are up to date.',
      forwardActions: '[AI STUB] Continue weekly cadence, monitor variance between TWG and TCS scores, and progress milestone completion. Real AI analysis available when AZURE_OPENAI_KEY is configured.',
    }
  }
}

class AzureOpenAIProvider implements AIProvider {
  private apiKey: string
  private endpoint: string
  private deploymentName: string

  constructor() {
    this.apiKey = process.env.AZURE_OPENAI_KEY!
    this.endpoint = process.env.AZURE_OPENAI_ENDPOINT!
    this.deploymentName = process.env.AZURE_OPENAI_DEPLOYMENT ?? 'gpt-4o'
  }

  async generateProgrammeReport(data: ProgrammeReportInput): Promise<ProgrammeReport> {
    const { weekEnding, totalTowers, ragCounts, towers, topRaidds, overdueActions, atRiskMilestones, pulseComments } = data

    const towerSummaries = towers.map(t =>
      `- ${t.name} (${t.group}, ${t.phase}): TWG ${t.twgScore ?? '—'}, TCS ${t.tcsScore ?? '—'}, RAG ${t.ragStatus ?? '—'}${t.overdueActions > 0 ? `, ${t.overdueActions} overdue actions` : ''}${t.blockers.length > 0 ? `, blockers: ${t.blockers.join('; ')}` : ''}${t.narrative ? `, narrative: ${t.narrative}` : ''}`
    ).join('\n')

    const raiddSummary = topRaidds.map(r => `- [${r.type}/${r.impact}] ${r.title} (${r.towerName})`).join('\n') || 'None'
    const actionsSummary = overdueActions.map(a => `- [${a.priority}] ${a.title} (${a.towerName})`).join('\n') || 'None'
    const milestoneSummary = atRiskMilestones.map(m => `- ${m.name} (${m.towerName}): ${m.status}`).join('\n') || 'None'
    const pulseSummary = pulseComments.map(p => `- ${p.towerName} / ${p.track}: "${p.comment}"`).join('\n') || 'None'

    const prompt = `You are a senior programme manager analysing a KT (Knowledge Transfer) transition programme.
Week Ending: ${weekEnding}
Total Towers: ${totalTowers} | GREEN: ${ragCounts.GREEN} | AMBER: ${ragCounts.AMBER} | RED: ${ragCounts.RED}

TOWER HEALTH SCORES:
${towerSummaries}

TOP RAIDD ITEMS (Risks/Assumptions/Issues/Dependencies/Decisions):
${raiddSummary}

OVERDUE ACTIONS:
${actionsSummary}

AT-RISK MILESTONES:
${milestoneSummary}

PULSE SURVEY COMMENTS:
${pulseSummary}

Respond ONLY with valid JSON in this exact structure (no markdown, no extra text):
{
  "summary": "2-3 sentence overall programme health summary",
  "workingWell": "Bullet-point list of what is working well across towers (3-5 points)",
  "notWorking": "Bullet-point list of key issues and what is not working (3-5 points)",
  "commonRisks": "Analysis of recurring risks and issues across multiple towers",
  "priorityActions": "Top 5 numbered priority actions leadership should take this week",
  "forwardActions": "Forward-looking actions and recommendations for improved KT progress over next 2-4 weeks"
}`

    const url = `${this.endpoint}/openai/deployments/${this.deploymentName}/chat/completions?api-version=2024-02-15-preview`
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'api-key': this.apiKey },
      body: JSON.stringify({
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.2,
        max_tokens: 1500,
      }),
    })

    if (!response.ok) throw new Error(`Azure OpenAI error: ${response.status}`)

    const result = await response.json()
    const text = result.choices?.[0]?.message?.content ?? '{}'
    try {
      return JSON.parse(text) as ProgrammeReport
    } catch {
      return {
        summary: text.slice(0, 500),
        workingWell: '', notWorking: '', commonRisks: '', priorityActions: '', forwardActions: '',
      }
    }
  }

  async generateSummary(submission: Partial<WeeklySubmissionDTO>, towerName: string): Promise<string> {
    const prompt = `You are a KT (Knowledge Transfer) programme manager writing an executive summary.
Tower: ${towerName}
Week Ending: ${submission.weekEnding}
Org: ${submission.org}
RAG Status: ${submission.ragStatus}
Total Score: ${submission.totalScore}/100
- Progress: ${submission.progressScore}/100
- Coverage: ${submission.coverageScore}/100
- Confidence: ${submission.confidenceScore}/100
- Operational: ${submission.operationalScore}/100
- Quality: ${submission.qualityScore}/100
Narrative: ${submission.narrative ?? 'None'}
Risks: ${JSON.stringify(submission.risks ?? [])}
Blockers: ${JSON.stringify(submission.blockers ?? [])}

Write a concise 2-3 sentence executive summary highlighting the health status, key risks, and recommended actions. Be factual and direct.`

    const url = `${this.endpoint}/openai/deployments/${this.deploymentName}/chat/completions?api-version=2024-02-15-preview`
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'api-key': this.apiKey,
      },
      body: JSON.stringify({
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.3,
        max_tokens: 300,
      }),
    })

    if (!response.ok) {
      throw new Error(`Azure OpenAI error: ${response.status}`)
    }

    const data = await response.json()
    return data.choices?.[0]?.message?.content ?? 'Summary unavailable.'
  }
}

export function getAIProvider(): AIProvider {
  if (process.env.AZURE_OPENAI_KEY && process.env.AZURE_OPENAI_ENDPOINT) {
    return new AzureOpenAIProvider()
  }
  return new StubAIProvider()
}
